load_refs(void) { const char *head_argv[] = { "git", "symbolic-ref", "HEAD", NULL }; static const char *ls_remote_argv[SIZEOF_ARG] = { "git", "ls-remote", opt_git_dir, NULL }; static bool init = FALSE; size_t i; if (!init) { if (!argv_from_env(ls_remote_argv, "TIG_LS_REMOTE")) die("TIG_LS_REMOTE contains too many arguments"); init = TRUE; } if (!*opt_git_dir) return OK; if (io_run_buf(head_argv, opt_head, sizeof(opt_head)) && !prefixcmp(opt_head, "refs/heads/")) { char *offset = opt_head + STRING_SIZE("refs/heads/"); memmove(opt_head, offset, strlen(offset) + 1); } refs_head = NULL; for (i = 0; i < refs_size; i++) refs[i]->id[0] = 0; if (io_run_load(ls_remote_argv, " ", read_ref) == ERR) return ERR; for (i = 0; i < ref_lists_size; i++) { struct ref_list *list = ref_lists[i]; size_t old, new; for (old = new = 0; old < list->size; old++) if (!strcmp(list->id, list->refs[old]->id)) list->refs[new++] = list->refs[old]; list->size = new; } return OK; }