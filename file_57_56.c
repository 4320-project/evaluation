H5Z_set_parms_array(const H5T_t *type, unsigned cd_values[]) { H5T_t *dtype_base = NULL; H5T_class_t dtype_base_class; size_t dtype_size; htri_t is_vlstring; herr_t ret_value=SUCCEED; FUNC_ENTER_NOAPI_NOINIT cd_values[cd_values_index++] = H5Z_NBIT_ARRAY; if((dtype_size = H5T_get_size(type)) == 0) HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "bad datatype size") cd_values[cd_values_index++]=dtype_size; if(NULL == (dtype_base = H5T_get_super(type))) HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "bad base datatype") if((dtype_base_class = H5T_get_class(dtype_base, TRUE)) == H5T_NO_CLASS) HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "bad base datatype class") switch(dtype_base_class) { case H5T_INTEGER: case H5T_FLOAT: if(H5Z_set_parms_atomic(dtype_base, cd_values) == FAIL) HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "nbit cannot set parameters for datatype") break; case H5T_ARRAY: if(H5Z_set_parms_array(dtype_base, cd_values) == FAIL) HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "nbit cannot set parameters for datatype") break; case H5T_COMPOUND: if(H5Z_set_parms_compound(dtype_base, cd_values) == FAIL) HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "nbit cannot set parameters for datatype") break; default: if((is_vlstring = H5T_is_variable_str(dtype_base)) < 0) HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "cannot determine if datatype is a variable-length string") if(dtype_base_class == H5T_VLEN || is_vlstring) HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "datatype not supported by nbit") if(H5Z_set_parms_nooptype(dtype_base, cd_values) == FAIL) HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "nbit cannot set parameters for datatype") break; } done: if(dtype_base) if(H5T_close(dtype_base) < 0) HDONE_ERROR(H5E_PLINE, H5E_CLOSEERROR, FAIL, "Unable to close base datatype") FUNC_LEAVE_NOAPI(ret_value) }