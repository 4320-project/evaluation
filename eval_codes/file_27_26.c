xmlXPathObjectPtr xmlXPathObjectCopy(xmlXPathObjectPtr val) { xmlXPathObjectPtr ret; if (val == NULL) return(NULL); ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject)); if (ret == NULL) return(NULL); memcpy(ret, val , sizeof(xmlXPathObject)); switch (val->type) { case XPATH_BOOLEAN: case XPATH_NUMBER: #ifdef LIBXML_XPTR_LOCS_ENABLED case XPATH_POINT: case XPATH_RANGE: #endif break; case XPATH_STRING: ret->stringval = xmlStrdup(val->stringval); if (ret->stringval == NULL) { xmlFree(ret); return(NULL); } break; case XPATH_XSLT_TREE: #if 0 if ((val->nodesetval != NULL) && (val->nodesetval->nodeTab != NULL)) { xmlNodePtr cur, tmp; xmlDocPtr top; ret->boolval = 1; top = xmlNewDoc(NULL); top->name = (char *) xmlStrdup(val->nodesetval->nodeTab[0]->name); ret->user = top; if (top != NULL) { top->doc = top; cur = val->nodesetval->nodeTab[0]->children; while (cur != NULL) { tmp = xmlDocCopyNode(cur, top, 1); xmlAddChild((xmlNodePtr) top, tmp); cur = cur->next; } } ret->nodesetval = xmlXPathNodeSetCreate((xmlNodePtr) top); } else ret->nodesetval = xmlXPathNodeSetCreate(NULL); break; #endif case XPATH_NODESET: ret->nodesetval = xmlXPathNodeSetMerge(NULL, val->nodesetval); if (ret->nodesetval == NULL) { xmlFree(ret); return(NULL); } ret->boolval = 0; break; #ifdef LIBXML_XPTR_LOCS_ENABLED case XPATH_LOCATIONSET: { xmlLocationSetPtr loc = val->user; ret->user = (void *) xmlXPtrLocationSetMerge(NULL, loc); break; } #endif case XPATH_USERS: ret->user = val->user; break; default: xmlFree(ret); ret = NULL; break; } return(ret); }